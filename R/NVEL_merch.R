#' Assign Log Grades based on Merchantability Specifications
#'
#' @description
#' `NVEL_merch` is a post-processing utility designed to work with log-level data,
#' typically generated by the `NVEL_buck` function in the `RForInvt` package.
#'
#' The function utilizes `data.table` non-equi joins to compare each log's
#' dimensions against a merchantability table. It assigns the "best" possible
#' grade to each log based on the lowest numerical value in the `Rank` column.
#'
#' @param df_logs A dataframe or data.table of logs. Must contain species,
#'   small-end diameter, log length, and the DBH of the tree.
#' @param df_specs A dataframe or data.table of merchantability specifications.
#' @param log_map A named list mapping internal logic to your `df_logs` column names.
#' @param spec_map A named list mapping internal logic to your `df_specs` column names.
#'
#' @return A data.table containing all original columns from `df_logs`, plus
#'   the matching columns from `df_specs` for the highest-ranking applicable grade.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' library(RForInvt)
#' library(data.table)
#'
#' # 1. Prepare dummy tree data
#' df_trees <- data.frame(
#'   tree_id = 1:2,
#'   Species = c("AF", "AF"),
#'   dbh = c(22.0, 10.5),
#'   ht = c(100, 60)
#' )
#'
#' # 2. Generate logs using NVEL_buck
#' df_logs <- NVEL_buck(
#'   df_trees,
#'   col_id = "tree_id",
#'   col_spp = "Species",
#'   col_dbh = "dbh",
#'   col_ht = "ht",
#'   log_len = 16.4
#' )
#'
#' # 3. Example Merch Specs
#' merch_specs <- data.table(
#'   Species = "DF",
#'   Sort = c("S", "S", "P"),
#'   Grade = c("4", "3", "0"),
#'   Label = c("Saw_h", "Saw_m", "Pulpwood"),
#'   Rank = c(1, 2, 3),
#'   MinDib = c(18, 12, 6),
#'   MinDbh = c(7, 7, 7),
#'   MinLen = c(3, 2, 1)
#' )
#'
#' # 4. Assign Grades (Merchandizing)
#' graded_logs <- NVEL_merch(df_logs, merch_specs)
#'
#' # View results
#' print(head(graded_logs))
#' }
NVEL_merch <- function(df_logs,
                       df_specs,
                       log_map = list(spp = "Species",
                                      dib = "dib_sm",
                                      len = "log_len",
                                      dbh = "dbh"),
                       spec_map = list(spp = "Species",
                                       rank = "Rank",
                                       mindib = "MinDib",
                                       mindbh = "MinDbh",
                                       minlen = "MinLen",
                                       maxdef = "MaxDef")) {

  if (!requireNamespace("data.table", quietly = TRUE)) stop("Package 'data.table' is required.")

  # Ensure we are working with data.tables and avoid modifying the user's original data
  dt_logs <- data.table::as.data.table(data.table::copy(df_logs))
  dt_specs <- data.table::as.data.table(data.table::copy(df_specs))

  # Use data.table::set instead of := to avoid the 'cedta' environment error
  # This creates a unique ID for every log row
  data.table::set(dt_logs, j = "..log_id..", value = seq_len(nrow(dt_logs)))

  # Define the join conditions (Non-Equi Join)
  # Logic: Species match AND log dimensions >= specification minimums
  join_on <- c(
    paste0(spec_map$spp, "==", log_map$spp),
    paste0(spec_map$mindib, "<=", log_map$dib),
    paste0(spec_map$mindbh, "<=", log_map$dbh),
    paste0(spec_map$minlen, "<=", log_map$len)
  )

  # Perform the join
  # nomatch = NULL ensures we only keep logs that meet at least one spec for now
  matched <- dt_specs[dt_logs, on = join_on, nomatch = NULL, allow.cartesian = TRUE]

  # If no matches found, return original logs with spec columns as NA
  if (nrow(matched) == 0) {
    for (col in names(df_specs)) {
      if (!(col %in% names(dt_logs))) {
        data.table::set(dt_logs, j = col, value = NA)
      }
    }
    data.table::set(dt_logs, j = "..log_id..", value = NULL)
    return(dt_logs)
  }

  # Selection Logic: Pick the record with the best Rank (lowest value) for each log
  # 1. Sort by log ID and then by Rank
  data.table::setorderv(matched, c("..log_id..", spec_map$rank))

  # 2. Keep the first occurrence of each log ID
  best_matches <- matched[, .SD[1], by = "..log_id.."]

  # Clean up: matched table contains extra columns from the join criteria
  # Keep only the original spec columns and the merge key
  keep_cols <- c("..log_id..", names(df_specs))
  best_matches <- best_matches[, ..keep_cols]

  # Merge back to the original logs to ensure 'Culls' (non-matches) are preserved
  res <- best_matches[dt_logs, on = "..log_id.."]

  # Remove the temporary row ID
  data.table::set(res, j = "..log_id..", value = NULL)

  return(res)
}
