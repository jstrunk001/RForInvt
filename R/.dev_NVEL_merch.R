#' Assign Log Grades based on Merchantability Specifications
#'
#' @description
#' `NVEL_merch` is a post-processing utility designed to work with log-level data,
#' typically generated by the `NVEL_buck` function in the `RForInvt` package.
#'
#' The function compares each log's dimensions (small-end diameter, length) and
#' the parent tree's DBH against a user-defined merchantability table. It
#' assigns the "best" possible grade to each log based on the lowest numerical
#' value in the `Rank` column. This allows for hierarchical grading (e.g.,
#' a log that qualifies for both "Saw" and "Pulp" will be assigned "Saw"
#' if "Saw" has a lower Rank value).
#'
#' @param df_logs A dataframe of logs. Must contain species, small-end diameter,
#'   log length, and the DBH of the tree the log came from.
#' @param df_specs A dataframe of merchantability specifications (e.g., loaded
#'   from the "Merch Specs" CSV).
#' @param log_map A named list mapping internal logic to your `df_logs` column names.
#'   Defaults: `spp = "Species"`, `dib = "dib_sm"`, `len = "log_len"`, `dbh = "dbh"`.
#' @param spec_map A named list mapping internal logic to your `df_specs` column names.
#'   Defaults: `spp = "Species"`, `rank = "Rank"`, `mindib = "MinDib"`,
#'   `mindbh = "MinDbh"`, `minlen = "MinLen"`, `maxdef = "MaxDef"`.
#'
#' @return A dataframe containing all original columns from `df_logs`, plus
#'   the matching columns from `df_specs` (Sort, Grade, Label, Value, etc.)
#'   for the highest-ranking applicable grade. Logs not meeting any spec
#'   will have `NA` values for the spec columns.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' library(RForInvt)
#'
#' # 1. Prepare dummy tree data
#' df_trees <- data.frame(
#'   tree_id = 1:2,
#'   Species = c("AF", "AF"),
#'   dbh = c(22.0, 10.5),
#'   ht = c(100, 60)
#' )
#'
#' # 2. Generate logs using NVEL_buck (from RForInvt)
#' df_logs <- NVEL_buck(
#'   df_trees,
#'   col_id = "tree_id",
#'   col_spp = "Species",
#'   col_dbh = "dbh",
#'   col_ht = "ht",
#'   log_len = 16.4
#' )
#'
#' # 3. Load your Merch Specs
#' merch_specs <- read.csv("TEST ID INVY Merch Specs.csv")
#'
#' # 4. Assign Grades (Merchandizing)
#' graded_logs <- NVEL_merch(
#'   df_logs = df_logs,
#'   df_specs = merch_specs
#' )
#'
#' # View results
#' head(graded_logs)
#' }
NVEL_merch <- function(df_logs,
                       df_specs,
                       log_map = list(spp = "Species",
                                      dib = "dib_sm",
                                      len = "log_len",
                                      dbh = "dbh"),
                       spec_map = list(spp = "Species",
                                       rank = "Rank",
                                       mindib = "MinDib",
                                       mindbh = "MinDbh",
                                       minlen = "MinLen",
                                       maxdef = "MaxDef")) {

  # 1. Create a temporary unique ID for each log row
  df_logs$..log_id.. <- seq_len(nrow(df_logs))

  # 2. Extract necessary columns from logs for comparison
  # We create a simplified dataframe to perform the join
  logs_tmp <- df_logs[, c("..log_id..", log_map$spp, log_map$dib, log_map$len, log_map$dbh)]
  colnames(logs_tmp) <- c("..log_id..", "spp_log", "dib_log", "len_log", "dbh_log")

  # 3. Join logs with specs based on Species
  # This creates a "long" format where every log is paired with every spec for that species
  matches <- merge(logs_tmp, df_specs, by.x = "spp_log", by.y = spec_map$spp, all = FALSE)

  # 4. Filter based on merchantability rules
  # We use the mapping to identify which columns in df_specs to compare against
  valid_matches <- matches[
    matches$dib_log >= matches[[spec_map$mindib]] &
    matches$dbh_log >= matches[[spec_map$mindbh]] &
    matches$len_log >= matches[[spec_map$minlen]],
  ]

  # 5. Selection Logic: Pick the best Rank (lowest value) for each unique log
  if (nrow(valid_matches) > 0) {
    # Sort by log ID and then by Rank ascending
    valid_matches <- valid_matches[order(valid_matches$..log_id.., valid_matches[[spec_map$rank]]), ]

    # Keep only the first occurrence of each log ID (which is the lowest Rank due to sorting)
    best_matches <- valid_matches[!duplicated(valid_matches$..log_id..), ]

    # Remove the temporary comparison columns before merging back
    cols_to_remove <- c("spp_log", "dib_log", "len_log", "dbh_log")
    best_matches <- best_matches[, !(names(best_matches) %in% cols_to_remove)]
  } else {
    # If no logs matched any specs, create an empty dataframe with spec columns for the join
    best_matches <- data.frame(..log_id.. = numeric(0))
  }

  # 6. Merge results back to the original log list
  # all.x = TRUE ensures we keep logs that didn't qualify for any grade (Culls)
  final_df <- merge(df_logs, best_matches, by = "..log_id..", all.x = TRUE)

  # 7. Final Cleanup: Remove the temporary ID and return
  final_df <- final_df[, names(final_df) != "..log_id.."]

  return(final_df)
}
